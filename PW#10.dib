#!meta

{"kernelInfo":{"defaultKernelName":"csharp","items":[{"aliases":[],"languageName":"csharp","name":"csharp"}]}}

#!markdown

# Практическая работа №10. Доставка сообщений до Команды.

**Цель:** Предоставить возможность обмена данными для длительных операций.

**Результаты:** После выполнения работы Вы сможете:
1. Отправлять сообщения длительной операции.

## Задание.
Поскольку длительная операция выполняется в течение некоторого момента времени, то может возникнуть необходимость
в предоставлении дополнительной информации, влияющей на ход выполнения. Поскольку Команды и источник данных часто находятся в разных потоках,
то сделать это надо потоко-безопасным образом. Самый простой способ - используя идиому Производитель-Поребитель, в нашем случае - очередь.

Набор данных, предназначенных для Команды будем называть сообщением. Можно использовать любую подходящую конструкцию языка программирования для 
представления сообщения. Необходимо учесть, что скорость доставки сообщений может быть выше, чем скорость обработки, а значит очередь сообщений должна быть
у каждой Длительной операции. При этом потоко-безопасные очереди требуют системных ресурсов, а значит, чтобы не получить ограничение на максимальное количество
одновремнно работающих длительных Команд, нельзя использовать потоко-безопасные очереди. 

Возможный вариант реализации - оставить одну потоко-безопасную очередь для потока, а для Команд использовать обычные очереди. Осталось только решить, как сообщение
излеченное из очереди потока попадет в очередь Команды. Один из возможных вариантов:
1. Каждая команда имеет уникальный идентификатор.
2. Сообщение содержит уникальный идентификатор Команлды, которому оно адресовано.
3. Для потока создаем специальную Длительную Команду, которая назвается Роутером. Он хранит коллекцию пар (id Команды, ссылка на очередь Команды). При вызове метода Execute этой 
Роутера, если очередь потока не пуста, происходит чтение очередного сообщения и по id Команды определяется очередь, куда это сообщение записывается.
Если id Команды не определен, на консоль выводится сообщение о невозможности доставить сообщение неизвестному адресату.
При старте новой Команды, ее очередь необходимо добавить в коллекцию Роутера. При остановке Команды - очередь удаляется из коллекции Роутера.

Продемонстрировать работу Роутера на двух Длительных Командах и на отправке сообщения несуществующей Команде.

**Материалы для самостоятельного изучения**.
1. [Паттерн Сообщение](https://www.enterpriseintegrationpatterns.com/patterns/messaging/Message.html)
2. [Паттерн Роутер - весь раздел про Роутеры](https://www.enterpriseintegrationpatterns.com/patterns/messaging/MessageRoutingIntro.html)
3. [Обмен сообщеними](https://www.enterpriseintegrationpatterns.com/patterns/messaging/MessageConstructionIntro.html)

#!markdown

using System;
using System.Threading;
using System.Collections.Concurrent;
using System.Collections.Generic;

public interface ICommand
{
    void Execute();
    bool IsCompleted { get; }
    int Id { get; }
    Queue<object> MessageQueue { get; }
}

public interface IScheduler
{
    bool HasCommand();
    ICommand Select();
    void Add(ICommand cmd);
}

public class RoundRobinScheduler : IScheduler
{
    private readonly ConcurrentQueue<ICommand> _commands = new ConcurrentQueue<ICommand>();
    private readonly ConcurrentQueue<ICommand> _runningCommands = new ConcurrentQueue<ICommand>();

    public bool HasCommand() => !_commands.IsEmpty || !_runningCommands.IsEmpty;

    public void Add(ICommand cmd) => _commands.Enqueue(cmd);

    public ICommand Select()
    {
        ICommand command = null;
        if (_runningCommands.TryDequeue(out command))
        {
            if (!command.IsCompleted)
            {
                return command;
            }
            return null;
        }
        else if (_commands.TryDequeue(out command))
        {
            _runningCommands.Enqueue(command);
            return command;
        }
        return null;
    }
}

public class ServerThread
{
    private readonly ConcurrentQueue<object> _messageQueue = new ConcurrentQueue<object>(); 
    private readonly IScheduler _scheduler = new RoundRobinScheduler();
    private bool _softStopFlag;
    private bool _hardStopFlag;
    private Thread _mainThread;
    private Router _router = new Router();

    public ServerThread()
    {
        _mainThread = new Thread(() =>
        {
            while (true)
            {
                ProcessCommands();
                ProcessMessages();

                if (_hardStopFlag)
                {
                    Console.WriteLine("Получена команда жёсткой остановки, останавливаюсь");
                    break;
                }

                if (_softStopFlag && !_scheduler.HasCommand())
                {
                    Console.WriteLine("Получена команда мягкой остановки, останавливаюсь");
                    break;
                }

                if (!_scheduler.HasCommand())
                {
                    Thread.Sleep(20);
                }
            }
        });

        _mainThread.Start();
    }

    private void ProcessCommands()
    {
        ICommand com = _scheduler.Select();
        if (com != null)
        {
            try
            {                
                com.Execute();
            }
            catch (Exception e)
            {
                Console.WriteLine($"Ошибка! {e.Message}. Продолжаю работу, игнорируя команду");
            }
        }
    }

    private void ProcessMessages()
    {
        while (_messageQueue.TryDequeue(out object message))
        {
            _router.RouteMessage(message);
        }
    }

    public int GetThreadId() => _mainThread.ManagedThreadId;

    public Thread GetThread() => _mainThread;

    public void SetSoftStop() => _softStopFlag = true;

    public void SetHardStop() => _hardStopFlag = true;

    public IScheduler GetScheduler() => _scheduler;
    
    ConcurrentQueue<ICommand> _commands;
    public void AddCommand(ICommand c)
    {
        _commands.Enqueue(c);
        _router.RegisterCommand(c);
    }

    public void SendMessage(object message)
    {
        _messageQueue.Enqueue(message);
    }
}

// Пример долгоиграющей команды:
public class TestCommand : ICommand
{
    private int _iterations;
    private int _currentIteration;
    private int _id;
    private Queue<object> _messageQueue = new Queue<object>();

    public TestCommand(int iterations, int id)
    {
        _iterations = iterations;
        _currentIteration = 0;
        _id = id;
    }

    public void Execute()
    {
        if (_currentIteration < _iterations)
        {
            Console.WriteLine($"TestCommand {_id}: Iteration {_currentIteration + 1}");
            _currentIteration++;
            Thread.Sleep(100); 

            while (_messageQueue.Count > 0)
            {
                object message = _messageQueue.Dequeue();
                Console.WriteLine($"TestCommand {_id}: Received message: {message}");
            }
        }
    }

    public bool IsCompleted => _currentIteration >= _iterations;

    public int Id => _id;

    public Queue<object> MessageQueue => _messageQueue;
}

// Роутер для отправки сообщений
public class Router
{
    private Dictionary<int, Queue<object>> _commandQueues = new Dictionary<int, Queue<object>>();

    public void RegisterCommand(ICommand command)
    {
        _commandQueues.Add(command.Id, command.MessageQueue);
    }

    public void UnregisterCommand(int id)
    {
        _commandQueues.Remove(id);
    }

    public void RouteMessage(object message)
    {
        Dictionary<string, object> messageDict = message as Dictionary<string, object>;
        if (messageDict != null && messageDict.ContainsKey("CommandId"))
        {
            int commandId = (int)messageDict["CommandId"];

            if (_commandQueues.ContainsKey(commandId))
            {
                _commandQueues[commandId].Enqueue(message);
                Console.WriteLine($"Router: Message sent to Command {commandId}");
            }
            else
            {
                Console.WriteLine($"Router: Unable to deliver message. Command {commandId} not found.");
            }
        }
        else
        {
            Console.WriteLine($"Router: Invalid message format. Unable to determine recipient.");
        }
    }
}

// Команды HardStop и SoftStop:
public class HardStop : ICommand
{
    private readonly ServerThread _th;

    public HardStop(ServerThread th)
    {
        _th = th;
    }

    public void Execute()
    {
        if (_th.GetThreadId() != Thread.CurrentThread.ManagedThreadId)
        {
            throw new Exception($"Wrong thread Id: need {_th.GetThreadId()}, got {Thread.CurrentThread.ManagedThreadId}");
        }
        _th.SetHardStop();
    }

    public bool IsCompleted { get; } = true;

    public int Id { get; } = -1; // Не используется для HardStop

    public Queue<object> MessageQueue { get; } = null; // Не используется для HardStop
}

public class SoftStop : ICommand
{
    private readonly ServerThread _th;

    public SoftStop(ServerThread th)
    {
        _th = th;
    }

    public void Execute()
    {
        if (_th.GetThreadId() != Thread.CurrentThread.ManagedThreadId)
        {
            throw new Exception($"Wrong thread Id: need {_th.GetThreadId()}, got {Thread.CurrentThread.ManagedThreadId}");
        }
        _th.SetSoftStop();
    }

    public bool IsCompleted { get; } = true;

    public int Id { get; } = -1; // Не используется для SoftStop

    public Queue<object> MessageQueue { get; } = null; // Не используется для SoftStop
}

public class Example
{
    public static void Main(string[] args)
    {
        ServerThread serverThread = new ServerThread();

        serverThread.AddCommand(new TestCommand(3, 1));
        serverThread.AddCommand(new TestCommand(5, 2));

        serverThread.SendMessage(new Dictionary<string, object>() { { "CommandId", 1 }, { "Message", "Hello, Command 1!" } });
        serverThread.SendMessage(new Dictionary<string, object>() { { "CommandId", 3 }, { "Message", "Hello, Command 3!" } });

        Thread.Sleep(1500);

        serverThread.AddCommand(new HardStop(serverThread));

        serverThread.GetThread().Join();

        Console.WriteLine("Поток завершен");
    }
}
